import os
import os.path as osp
import random
import glob

import torch
import numpy as np
from tqdm import tqdm
import scipy.stats as stats

from networkx.algorithms.isomorphism import GraphMatcher
from python_graphs import program_graph
from torch_geometric.data import Dataset
from torch.utils.data import DataLoader
from typing import Optional, Callable, List

from codescholar.utils.graph_utils import save_as_json, program_graph_to_nx
from codescholar.utils.train_utils import featurize_graph


def my_collate(batch):
    '''dummy collate fn to just return data as is'''
    return batch


class Corpus:
    """Generator for graphs saved in a dataset file to train models.

    Iteratively, new batch of graphs (positive and negative)
    are generated by sampling from the dataset.
    """
    def __init__(self, dataset, n_samples):
        self.dataset = ProgramDataset(
            root=f"./tmp/{dataset}",
            name=dataset,
            n_samples=n_samples)
    
    def gen_data_loader(self, batch_size, train=True):
        return DataLoader(
            self.dataset,
            collate_fn=my_collate,
            batch_size=batch_size,
            sampler=None,
            shuffle=False)


class ProgramDataset(Dataset):
    def __init__(
        self,
        root: str,
        name: str,
        n_samples: int,
        transform: Optional[Callable] = None,
        pre_transform: Optional[Callable] = None,
        pre_filter: Optional[Callable] = None,
        save_json: Optional[bool] = False,
        min_size=2, max_size=30
    ):
        self.name = name
        self.save_json = save_json
        self.json_dir = osp.join(root, 'networkx')
        self.digraph_dir = osp.join(root, 'digraphs')
        
        if not os.path.exists(self.digraph_dir):
            os.makedirs(self.digraph_dir)
        
        self.n_samples = n_samples
        self.min_size = min_size
        self.max_size = max_size

        super().__init__(root, transform, pre_transform, pre_filter)
    
    def download(self):
        pass

    @property
    def num_node_labels(self) -> int:
        return self.sizes['num_node_labels']

    @property
    def num_node_attributes(self) -> int:
        return self.sizes['num_node_attributes']

    @property
    def num_edge_labels(self) -> int:
        return self.sizes['num_edge_labels']

    @property
    def num_edge_attributes(self) -> int:
        return self.sizes['num_edge_attributes']
    
    @property
    def raw_file_names(self) -> List[str]:
        names = sorted(glob.glob(osp.join(self.raw_dir, '*.py')))
        names = [os.path.basename(file) for file in names]
        return names

    @property
    def processed_file_names(self) -> str:
        names = sorted(glob.glob(osp.join(self.processed_dir, '*.pt')))
        names = [os.path.basename(file) for file in names]
        return 'not_implemented.pt'

    def pre_transform(self, data):
        return data
    
    def process(self):
        """process and store python graphs as a Data object onto the disk
        """
        count = 0
        program_size = []

        # Convert each python file to networkx graphs and save json
        for raw_path in tqdm(self.raw_paths, desc="Preprocess"):
            data = self.create_prog_datapoint(raw_path)

            if self.pre_filter is not None and self.prefilter(data):
                continue

            if self.pre_transform is not None:
                data = self.pre_transform(data)

            if self.save_json is True:
                save_as_json(
                    data,
                    osp.join(self.json_dir, f'data_{count}.json'))

            torch.save(data, osp.join(self.digraph_dir, f'data_{count}.pt'))
            program_size.append(len(data))
            count += 1
        
        # Create randomly mutated examples and store in self.processed_dir
        self.random_samples_generator(program_size, count)

    def random_samples_generator(self, program_size, count):
        """Steps:
        1. choose a random size for graph
        2. choose a random target graph
        3. perform random bfs traversal in neighborhood = size
        4. choose a random but anchored query = positive e.g.
        5. repeat for negative e.g. with different random graph"""
        
        for idx in range(self.n_samples):
            size = random.randint(self.min_size + 1, self.max_size)
            graph, t = self.sample_neigh(program_size, count, size)
            q = t[:random.randint(self.min_size, len(t) - 1)]

            anchor = list(graph.nodes)[0]
            pos_t_anchor = anchor
            pos_q_anchor = anchor

            neigh_t, neigh_q = graph.subgraph(t), graph.subgraph(q)
            pos_t = neigh_t
            pos_q = neigh_q

            size = random.randint(self.min_size + 1, self.max_size)
            graph_t, t = self.sample_neigh(program_size, count, size)
            graph_q, q = self.sample_neigh(
                program_size, count,
                random.randint(self.min_size, size - 1))
            
            neg_t_anchor = list(graph_t.nodes)[0]
            neg_q_anchor = list(graph_q.nodes)[0]

            neigh_t, neigh_q = graph_t.subgraph(t), graph_q.subgraph(q)
            neg_t = neigh_t
            neg_q = neigh_q

            # translate to DeepSnap Graph
            pos_t = featurize_graph(pos_t, pos_t_anchor)
            pos_q = featurize_graph(pos_q, pos_q_anchor)
            neg_t = featurize_graph(neg_t, neg_t_anchor)
            neg_q = featurize_graph(neg_q, neg_q_anchor)
            
            data = [pos_t, pos_q, neg_t, neg_q]

            torch.save(data, osp.join(self.processed_dir, f'data_{idx}.pt'))

    def sample_neigh(self, ps, count, size):
        """random bfs walk to find neighborhood graphs of a set size
        """
        ps = np.array(ps, dtype=np.float)
        ps /= np.sum(ps)
        dist = stats.rv_discrete(values=(np.arange(count), ps))

        while True:
            idx = dist.rvs()
            graph = torch.load(osp.join(self.digraph_dir, f'data_{idx}.pt'))

            start_node = random.choice(list(graph.nodes))
            neigh = [start_node]
            frontier = list(set(graph.neighbors(start_node)) - set(neigh))
            visited = set([start_node])

            while len(neigh) < size and frontier:
                new_node = random.choice(list(frontier))

                assert new_node not in neigh

                neigh.append(new_node)
                visited.add(new_node)
                frontier += list(graph.neighbors(new_node))
                frontier = [x for x in frontier if x not in visited]

            if len(neigh) == size:
                return graph, neigh

    def create_prog_datapoint(self, path):
        prog_graph = program_graph.get_program_graph(path)
        digraph = program_graph_to_nx(prog_graph, directed=True)

        return digraph

    def len(self):
        return self.n_samples
    
    def get(self, idx):
        """load a python method (graph) from disk.
        """
        data = torch.load(osp.join(self.processed_dir, f'data_{idx}.pt'))        
        return data
